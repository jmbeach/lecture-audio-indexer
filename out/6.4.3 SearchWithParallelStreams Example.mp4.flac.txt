Now that we talked about how to visualize the hook methods for the search with parallel streams case. Study example, let's go ahead and take a look at how to implement these hook methods. And again, just to remind you that the reason for doing what we're doing here. The reason for using parallel streams is to get this massive speed up and performance, which if you take a look at this is basically not linear superlinear in the number of cores on the laptop. I ran the experiments on the reason why the results are actually superlinear in the better than linear is because I even though I have four cores, their hyper-threaded, which means they're able to do some overlapping of instructions and pipe lining in order to get the performance even higher than just a factor of and it's really not quite a double end, but it's more than end. So if it were and is a member, of course, so this really does give you a big win and we'll talk more about the reasons why that is little bit later.
Let's talk about how we might implement the process stream method. Now that the key thing to know it, before we talked with anything here is his only one minuscule change to process.
 Stream in this implementation.
 All we're doing is replacing the use of stream with parallel strength. And what that does under the hood is that goes ahead and uses the arraylist split erator.
 To create a parallel stream, that will search the array list of input strings in multiple worker threats.
 So basically each as the way the arraylist splitter works as well as well. Look at Royal actually walk through the source code for the arraylists literator to show you exactly how it works. But basically what it is, it's doing. Is it ends up splitting? The arraylist up into chunks were each chunk is a single element in the array list and each of those elements will then be processed by separate worker thread or some workers read in the common folk doing full. So, this is very efficient. Very fine. Grain and has received gives us this wonderful speed up.
 You can put string is that's that's broken up. Using a splitter is processed in parallel using to come and Fork join pool. And so we'll see that. Again is very fine-grained level of parallels. And basically each work of Shakespeare will have its own thread in the pool, that will get a chance to run when, when it's time to run.
 What then happens basically like we saw before the map intermediate operation gets called passing in the process input.
 Helper method which will then turn around and search that give an input string to locate all the phrases that we care about in Hamlet or what not.
 and then that will, of course, come back with a
 list or other extreme of lists.
 Search results. And then the collector operation gets called and it uses the to list Factor method to return it on, concurrent collector which obeys encounter order. And we'll end up basically creating a list of lists that merge everything back together and return that as the result from process string.
 Pretty much the same as before. Honestly, the only real difference here is the fact that we changed stream two parallel streams, use a different Factor method and that's often not always, but often the way things work, with Carol Streams. It's almost dropped. It easy to go from a sequential stream to a parallel stream, which is one of the virtues of this is functional, programming abstraction.
 Let's take a quick look at process input as before. It also has just one minuscule change.
 It goes ahead and uses parallel stream on the phrases to find which once again, uses the arraylists literator to create a parallel stream, that will search giving him put string in a given work of Shakespeare to locate all the phrase occurrences. I keep saying these occurrences have got to fix this. Sorry about that. As you can see here, what we do when we call the search for phrase method, in the context of the Lambda expression passed into the map intermediate operation. We end up passing the false parameter as the fourth argument to search for phrase. And what that does is that will use a sequential screen to search for the phrase. So it'll generate a sequential stream of results when we come back later in subsequent weeks and talk about the search with parallel, splitter example, you'll see how
 Play the false with true here, which will cause search for phrase to go ahead and return a parallel screen. So it'll do the searching in even more find degrees of paralyzation, which is really cool.
 Then as you can see here, each phrase and input string is processed in parallel, in the common Fork, join pool.
 And as before we go ahead and filter out things that are empty. We collect the results back that triggers are me that operation processing and then merge is all the results into a single list of search results, which is what gets returned as the result of the process input method. So once again, just to kind of recapped this, it's very much identical to what type of four with just, those tiny minuscule changes to go from stream to Carol Stream.