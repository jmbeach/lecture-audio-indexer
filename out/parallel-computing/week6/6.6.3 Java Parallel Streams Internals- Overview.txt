We're not going to turn our attention to one of the processing phases and discuss the order of processing and we'll see. Once again, it's important to know what you can change and what you can't change.
 So let's talk about stream processing order. What the heck does that mean? Well, keep in mind when we talk about processing order were in the apply face and this is the phase where the chunks that were created by the split phase. Are they a map to the underlying common for drain pool to be running parallel. Now, it turns out that the order in which the chunks in a parallel streamer, processed is intentionally non-deterministic. What that means is is you have no control over it and will happen here, is that the way in which the fork join pool, takes the tasks that it's been given and runs them. Can be different for different Ron's, be different on different Hardware different. A different operating systems different, different versions of the job of execution, environment. Java virtual machine is still on, even for the same input.
 And programmers have little or no control over that. You just can't do anything about it. And that's actually by Design. The reason for doing this, is it enables the various layers in the job execution environment JDM Java virtual machine or something. Like the Android Arch runtime environment, which uses ahead of time compilation is supposed to work. The machine and interpretation. All of these kinds of things can be optimized in ways that are transparent to your coat. So the way in which tasks are scheduled and executed in the fork, join pool on the execution environment that they, the end, the hard work or is the operating system after system thread, all of those things to be optimized in a way that's totally transparent to you. And that's a good thing. You don't really want to have to know about those details.
 Good example, of where Salon determines that might come from, is the fork join framework? Support for work stealing to talk a lot about work stealing when we talked about before. Join framework. We'll talk a little bit about it when we talk about how the parallel streams framework uses for join pool, but they see what happens is if you've got the workers Fred's in the fourth join. Have their own internal to which is called a deck for a double-ended cute and whenever a worker thread has no work on its deck, it turns around and tries to steal available work from other workers threads decks in order to be able to have the performance maximized of the CPU of the multi-core processors. And the reason for doing this is to improve overall, through put in the system, but it also leads to a lot of non determinism and that's perfectly. Okay. That's what you want.