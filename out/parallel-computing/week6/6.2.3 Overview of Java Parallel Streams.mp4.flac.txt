Now, that I've given you a little taste of the job of parallel streams programming model, and you see a little bit about how it works with a hood. Let's spend a few minutes talking about how to avoid common programming hazards. When try to apply this framework in practice. And, of course, they're the goal. Here is to try to help you learn the common mistakes that the beginners, make like myself when I was running this. So you'll hopefully right more robust and resilient and scalable Java Carlos dreams code. This is essentially an extension, in an augmentation of some of the earlier discussions. We had in the streams lessons or we talked about some of the common program in the steaks for sequential stripes.
So course, one of those the key is used to watch out for one of the key hazards in any type of concurrent or pillow program is how to avoid the dreaded race conditions, which arise when an application depends on the sequence or the timing of the threads. In order for it to operate properly and we really want to avoid race conditions to the end of corrupting the data in very subtle and pernicious ways. Now, the job, a parallel streams framework has a very fundamental assumption. It assumes that the behaviors that you give it to Ron and its aggregate operations. Don't incur race conditions.
The easiest way to do this is simply to avoid behaviors, that have any side effects. So if you make sure you use stateless Lambda expressions or method references, that's one of the easiest ways to avoid these problems.
 You get yourself into trouble when the results depend on shared wheedle States. If you have shared Lambda expressions or shared method, references really bad things could happen. So let's take a look at an example that illustrates this problem. I've shown this example before, but now that were talking that parallel streams. It's probably going to be a little bit more meaningful for you to get a deeper understanding of what it's about.
 What is examples actually in the ex16 folder in my GitHub repository and it's the buggy factorial class. And as you'll see here, what will happen is, we'll have a state that's not protected by any synchronizer that gets changed by different threads during the parallel execution of a stream Pipeline, and that's going to cause chaos and Insanity. Surprisingly. So, here's the method factorial, this buggy is incorrect, and it's incorrect not because the logic is wrong because it isn't properly synchronized.
 As you can see, we make ourselves an instance of a class called total. And as you can see, if you look at the total, total is a class that has a field called M total which is initialize to one and we create one. And it only one instance of this, this total class.
 If you take a close look, just see that the most method in the total class, takes the M, total field and auto multiplies it by end. So it multiplies and total by Anton and stores the results back into M. Total steps with the the x equal operator does in Java.
 Now everything's fine at this, run sequentially. But if we put the parallel keyword in here, if you put the parallel call to the function parallel, which makes the stream parallel what'll happen, then it'll be a group of threads in a pool that will run and those threads all simultaneously. Be calling the molt method on the M total field, which is shared mutable State. Cuz obviously, it's being changed, but it's not synchronized. There was a result, you'll end up with race conditions Galore and all kinds of horrible things will happen for. Just for kicks. Try running this program and see what the results are. You're probably get strange results. May differ. Every time you run, is also some other subtle issues here with respect to memory visibility for trying to return. The T. M. Total feel that also is not properly locked but just rest assured. This code is full of bugs and it looks very cool at first glance, but it's actually really bad.
 Not surprisingly. We'll come back later and try to fix this code by using other features like that job at Terminal operations, such as collected works properly for this case.
 Another problem, which I've also outline before the context of sequential streams, but becomes even more problematic in the context of parallel streams is so-called interference with the data source and this occurs when the source of a stream is modified with in the pipeline. So that the real key thing here is don't change your data sources while they're working while they're being worked upon by a stream, either a sequential streamer apparel strength.
 This example goes ahead and create a list of 10 integers with the value of 0 through 9. And you can see this is just ever so different from the one I showed before when we talked about common problems with sequential streams. What we do here is to make it in stream of the values, 0 through 9, Wii box. Those primitive in sin two integers with your reference types. And then we collect them. Using the two collection Factor method from the collectors utility class passing in the arraylist Constructor reference, which will allocate the list using an arraylist. So now we have an arraylist of zero through nine integers.
 So far so good. Here's where the cat and the chaos and Insanity breaks out. So what we do now is we create a parallel stream and we call Pete because I think I mentioned before is really just stood about the bugging aided. It just is supposed to log, something. Or look at the values. It's not supposed to do anything with side effects. But just to cause problems we pass in the list, colon colon removed method refer, which of course, will be removing elements from the list as we're iterating through them in parallel and try to print them out. And so really bad things will happen. You'll probably get exceptions. You'll get weird results. So the bottom line is do not use code in that right code, that has interference with a data source for either sequential or parallel streams.
 If you have behaviors that don't have shirt State, and don't have any side effects other than just simply returning a result. These are what you want to use for parallel streams because they require no explicit synchronization. You can just run them. The parallel streams framework less than running parallel. They're effectively embarrassingly parallel computations with no dependents sees. No, need to communicate anything else and that's really what the streams framework would prefer that you do.
 Here are some examples. We've seen some of these from before for example of that the search for phrase method that we talked about when we discussed, are sequential search screen example, goes ahead and uses this phrase match splitter Raider. As you can see, there's really no side effects here. Just goes ahead and returns an object of type of search results. So that's all nice and pure. Likewise. The, the is empty method from search results to check to see if those sizes listed zero. That's also pure. So these are things that we don't have to worry about being being buggy, having concurrency hazards, parallelism hazards race conditions in someone.
 If you need to access and update, shared middle state in apparel stream, which sometimes does happen. For example, of say, you have some kind of a cash like a Casper images. For instance. Make sure that it's properly synchronized. We might have an image of cash to fuse to cash, the content of downloaded images that are downloaded from remote servers and probably the best way to do this to protect that cached data in the face of multiple threads running in parallel, is simply to use a concurrent hashmap, which is a concurrent collection. It comes out of the Java Collections framework, which is really well, designed and optimized to work effectively for multiple access from thread, both reading and writing to it as you can see what it thinks. It makes it efficient, is it has a bunch of different locks so you don't end up with single points of contention. And it's also very carefully designed to allow multiple.
 He accesses to all going parallel and even if you do right accesses, if you don't end up writing to the same bucket, wear something else is writing to once again is No contention for the locks. So it's super fast super Optimizer, scalable and a great way to protect your data without having to do the synchronization yourself in your own coat. And of course, if you really do have to synchronize data structures in your own code, in Palestine, make sure that you use the appropriate synchronizers that we've covered in. In other courses, such as my second run object-oriented programming course, which will teach you how to use synchronizers like ranch with locks or monitor locks, and so on.