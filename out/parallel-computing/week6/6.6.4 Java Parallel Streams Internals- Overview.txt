So continuing on with our discussion of the order of processing, I mentioned earlier that you have no control or little control over the order of processing, but not trying to talk about the control. You have over the order of results. That turns out that as we'll see, you actually do have some control over the order of the results. Start by giving an overview of, what does it mean to have results ordering in the first place?
 So first and foremost, the processing results of the parallel stream can be controlled More deterministic Lie than the ordering of the processing.
 So this is very important thing to keep in mind, programmers can control if the results will be presented in, what's known as encounter order. And encounter order is, simply the order in which the streams Source native elements available. So using our example, from the search stream gang history. Remember we had the situation is where we had the works of Shakespeare coming in in a list of strengths. So, encounter order would be the order in which each work of Shakespeare occurred in that original list. So if Julius Caesar came first followed by Hamlet, followed by Macbeth, followed by Henry, the 5th or whatnot, then that would be the encounter order and you can dictate whether encounter order should be preserved or not when the results come back from the terminal operation, say, collect.
 No, encounter order, Oreo will be maintained under certain circumstances. And those circumstances are the original Source. Has ordered properties ordered characteristic is set builder. Flag is set and at the aggregate operations that are used as part of the stream pipeline are obliged to maintain order and think just kind of think back to our earlier discussions, about how the streams framework internals process a stream where you end up with these flags that set properties at each of the stages in the pipeline. That's kind of what we're talking about here.
 It turns out that the semantics in terms of whether you get the same results will be identical, irrespective of whether the stream runs in parallel or other ones sequentially, but it's kind of like, know if you have miles per hour in kilometers per hour. If you can have a car going the same speed but one will be read in miles per hour when we were in kilometers per hour, but it's the same speed of the result is the same. So similar Concepts hear the semantics of the same irrespective of whether the stream is power or sequential. If doctor order must be preserved. If encounter order does not need to be reserved, then you make it different result. But again, that's that's by Design.
 The main reason for keeping track of whether you want, encounter order to be preserved. However really comes down to Performance. So the more you need encounter order to be preserved, the bigger the performance hit, the less you care about encounter order.
 Lower the performance hit things will actually run a lot faster. If you don't care about the order in which the results show up.