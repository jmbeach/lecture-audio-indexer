00:00.600 --> 00:01.000
So

00:01.000 --> 00:04.500
let's start by talking about the order of results for collections

00:04.500 --> 00:10.200
and we'll see that there's certain Collections and their properties that affect the results order

00:11.100 --> 00:15.000
And I'll show you a bunch of examples are these examples all appear in

00:15.000 --> 00:19.800
my ex21 folder in my GitHub repository

00:19.800 --> 00:23.100
So I strongly recommend that you take a look at this coat

00:23.100 --> 00:27.700
It is very destructive and there's lots of comments and you can run it and see what the results are ensign

00:29.000 --> 00:34.100
So it turns out that certain types of Collections and certain properties collections

00:34.100 --> 00:38.700
maintain encounter order in particular ordered splitter

00:38.700 --> 00:43.900
Raiders ordered collection and certain static stream Factory methods

00:43.900 --> 00:46.900
those things maintain encounter order

00:46.900 --> 00:54.500
So let's take a look at an example examples throughout this lesson to the encounter order

00:54.500 --> 00:56.600
Here is shown by this array

00:56.600 --> 00:59.500
there were creating and then converting into a list

00:59.500 --> 01:03.100
And the encounter order here is 23142

01:03.100 --> 01:05.500
So in this particular case

01:05.500 --> 01:08.700
the list is ordered

01:08.700 --> 01:10.600
even though it doesn't have to be unique

01:10.600 --> 01:12.000
we can have duplicates

01:12.000 --> 01:13.600
We can have two appearing twice

01:13.600 --> 01:14.100
For example

01:14.900 --> 01:15.400
So

01:15.400 --> 01:16.500
when we say list

01:16.500 --> 01:19.100
Parallel stream because it's a list

01:19.100 --> 01:22.400
we know it's going to have the order

01:24.000 --> 01:24.700
Encoded

01:24.700 --> 01:25.400
or enforce

01:25.400 --> 01:27.900
the encounter order will be must be enforced for that

01:27.900 --> 01:28.900
Recall

01:28.900 --> 01:29.400
By the way

01:29.400 --> 01:31.600
that ordered is not the same thing as sort it

01:31.600 --> 01:37.900
So you can see that this list is ordered to 3142, but that list is not sorted

01:37.900 --> 01:39.900
It's just order a little bit confusing

01:39.900 --> 01:42.500
but don't don't confuse or conflate those two terms

01:43.600 --> 01:48.400
The next thing that happens is that we're going to filter out values

01:48.400 --> 01:51.400
We only allow even numbers to progressed to the string

01:51.400 --> 01:56.400
And if you recall back to our discussion of the filter in operation

01:56.400 --> 01:58.900
we talked about cyclical stream internals

01:58.900 --> 02:00.800
which don't change here

02:00.800 --> 02:06.400
We talked about the fact that filter doesn't change the ordering property

02:06.400 --> 02:09.300
If may change the size property cuz there may be fewer things

02:09.300 --> 02:09.900
in this case

02:09.900 --> 02:13.400
We drop out all the odd numbers but ordering is preserved

02:14.400 --> 02:18.600
Next thing we do is we take each number and we multiply it by 2

02:19.600 --> 02:20.300
Once again

02:20.300 --> 02:23.000
map will preserve ordering

02:23.000 --> 02:26.200
It may not can be distinct

02:26.200 --> 02:27.200
It may not be sorted

02:27.200 --> 02:28.900
but it will be ordered

02:28.900 --> 02:30.000
And then

02:30.000 --> 02:37.600
the last thing we do is we use the to array terminal operation to convert the stream of even numbers

02:37.600 --> 02:42.700
* 2 into an array of integers

02:44.500 --> 02:58.200
And the results here must be ordered must show up as 484 cuz we got rid of the odd numbers and we had to preserve the encounter order and that's because our list is an ordered collection

02:58.200 --> 02:59.400
Okay

02:59.400 --> 03:00.300
Hopefully that's pretty clear

03:00.300 --> 03:01.300
I think it's pretty straightforward

03:03.000 --> 03:06.900
Unordered collections don't need respect encounter order

03:06.900 --> 03:09.800
So let's take a look at an example that will demonstrate this

03:09.800 --> 03:11.300
In this example

03:11.300 --> 03:16.200
We take in a re convert it into a list Natok

03:16.200 --> 03:30.500
It's the same way as before and then turn that into a hash set and a half set is unordered and unique so we know right away that they'll only be one to hear instead of tutus because hash that is going to be unique

03:30.500 --> 03:32.200
What I have said is also an order

03:32.200 --> 03:37.000
There's no ordering maintain a task that just whatever the half is happened to Hash to

03:38.100 --> 03:40.200
So when we run this program

03:40.200 --> 03:41.800
couple things will happen

03:41.800 --> 03:49.700
The code could actually execute faster and that's because we don't need to maintain encounter order when we're done

03:49.700 --> 03:51.300
And so is a result

03:51.300 --> 04:03.700
we might come back with the order being being eight 4 or for 8, cuz it's only be one for not to because of that is got unique values

04:03.700 --> 04:06.800
but we don't have to maintain a bit red that we

04:06.800 --> 04:07.500
that the streams

04:07.500 --> 04:11.000
Parallel streams invitation does not have to maintain that encounter order

04:11.000 --> 04:11.900
So as a result

04:11.900 --> 04:13.800
it is likely to run faster