So, let's start by talking about the order of results for collections, and we'll see that there's certain Collections and their properties that affect the results order.
 And I'll show you a bunch of examples are these examples all appear in, my ex21 folder in my GitHub repository. So I strongly recommend that you take a look at this coat. It is very destructive and there's lots of comments and you can run it and see what the results are ensign.
 So it turns out that certain types of Collections and certain properties collections, maintain encounter order in particular ordered splitter, Raiders ordered collection and certain static stream Factory methods, those things maintain encounter order. So let's take a look at an example examples throughout this lesson to the encounter order. Here is shown by this array, there were creating and then converting into a list. And the encounter order here is 23142. So in this particular case, the list is ordered, even though it doesn't have to be unique, we can have duplicates. We can have two appearing twice. For example.
 So, when we say list. Parallel stream because it's a list, we know it's going to have the order.
 Encoded, or enforce, the encounter order will be must be enforced for that. Recall. By the way, that ordered is not the same thing as sort it. So you can see that this list is ordered to 3142, but that list is not sorted. It's just order a little bit confusing, but don't don't confuse or conflate those two terms.
 The next thing that happens is that we're going to filter out values. We only allow even numbers to progressed to the string. And if you recall back to our discussion of the filter in operation, we talked about cyclical stream internals, which don't change here. We talked about the fact that filter doesn't change the ordering property. If may change the size property cuz there may be fewer things, in this case. We drop out all the odd numbers but ordering is preserved.
 Next thing we do is we take each number and we multiply it by 2.
 Once again, map will preserve ordering. It may not can be distinct. It may not be sorted, but it will be ordered. And then, the last thing we do is we use the to array terminal operation to convert the stream of even numbers. * 2 into an array of integers.
 And the results here must be ordered must show up as 484 cuz we got rid of the odd numbers and we had to preserve the encounter order and that's because our list is an ordered collection. Okay? Hopefully that's pretty clear. I think it's pretty straightforward.
 Unordered collections don't need respect encounter order. So let's take a look at an example that will demonstrate this. In this example. We take in a re convert it into a list Natok. It's the same way as before and then turn that into a hash set and a half set is unordered and unique so we know right away that they'll only be one to hear instead of tutus because hash that is going to be unique. What I have said is also an order. There's no ordering maintain a task that just whatever the half is happened to Hash to
 So when we run this program, couple things will happen. The code could actually execute faster and that's because we don't need to maintain encounter order when we're done. And so is a result, we might come back with the order being being eight 4 or for 8, cuz it's only be one for not to because of that is got unique values, but we don't have to maintain a bit red that we, that the streams. Parallel streams invitation does not have to maintain that encounter order. So as a result, it is likely to run faster.