00:00.000 --> 00:05.000
Not if you had a chance to Showcase and revisit the search with stream

00:05.000 --> 00:09.700
gang case study and show how easy it was to go from sequential to parallel streams

00:09.700 --> 00:14.800
It's a good time to take a step back and look at the internals of parallel streams

00:14.800 --> 00:17.700
Have a better understanding of how things work under the hood

00:17.700 --> 00:21.000
I gave you a quick synopsis of this earlier this week

00:21.000 --> 00:27.900
but now I'm really going to go into more detail and really look in great depth about how Carol Streams works

00:27.900 --> 00:28.500
If it's really

00:28.500 --> 00:29.400
really fast name

00:30.700 --> 00:33.100
As we talked about earlier and earlier weeks

00:33.100 --> 00:36.000
when we discussed sequential stream internals

00:36.000 --> 00:39.900
one of the first and most important things to understand

00:39.900 --> 00:43.300
is what aspects of the parallel stream framework

00:43.300 --> 00:46.100
you can change and what aspects

00:46.100 --> 00:47.100
You can't change

00:47.100 --> 00:49.500
You just have to come to grips with the fact

00:49.500 --> 00:51.600
you can't change everything and then that's by Design

00:51.600 --> 00:52.900
There's a lot of reasons

00:52.900 --> 00:56.700
Why the parallel streams framework is designed and implemented the way it is

00:56.700 --> 00:59.600
and you might quibble with some of the design choices

00:59.600 --> 01:01.200
but I think you'll find a practice

01:01.200 --> 01:03.100
It's it's really quite quite good

01:03.100 --> 01:06.100
especially considering you don't have to write it documented

01:06.100 --> 01:07.200
maintain it

01:07.200 --> 01:08.200
the bucket and someone

01:09.800 --> 01:12.100
The first question of course is why do we care

01:12.100 --> 01:12.800
Who cares

01:12.800 --> 01:14.300
how I parallel streams Works

01:14.300 --> 01:16.000
Shouldn't we just be happy

01:16.000 --> 01:16.800
That it works so well

01:16.800 --> 01:19.100
and in fact we've seen it

01:19.100 --> 01:21.400
It's actually quite easy to to be parallel

01:21.400 --> 01:23.200
So why do we do think some of the hood

01:23.200 --> 01:24.200
Well

01:24.200 --> 01:25.300
as you'll see very quickly

01:25.300 --> 01:27.500
if you're just having fun

01:27.500 --> 01:31.500
riding little demo program for teaching a class and it casually

01:31.500 --> 01:34.400
it's probably not that important to know all the details internally

01:34.400 --> 01:35.400
However

01:35.400 --> 01:38.100
if you're trying to write performance critical applications

01:38.100 --> 01:43.200
it's essential to understand how streams and parallel streams

01:43.200 --> 01:43.800
work internally

01:43.800 --> 01:49.300
because if you understand how it works you be more likely to use the right features in the right combinations

01:49.300 --> 01:51.100
In order to get the right performance

01:51.100 --> 01:53.100
that you need to meet your requirements

01:55.100 --> 01:56.400
To start this discussion

01:56.400 --> 01:57.200
just recall

01:57.200 --> 01:59.700
There were three phases of a parallel stream

01:59.700 --> 02:01.000
I'm not going to dwell on this

02:01.000 --> 02:02.200
cuz we've covered it several times

02:02.200 --> 02:04.600
But this sets up a discussion of what can change

02:04.600 --> 02:05.400
what can't change

02:05.400 --> 02:07.600
There's the splitting phase

02:07.600 --> 02:09.400
where we use a splitter Raider to partition

02:09.400 --> 02:15.000
The datastore stuff into multiple chunks is the apply phase where we independently process

02:15.000 --> 02:17.500
These chunks in workers threads

02:17.500 --> 02:19.700
and accounted for showing full Ellen

02:19.700 --> 02:21.200
Finally have the combined phase

02:21.200 --> 02:26.400
which joins the partial sub results and merge them together into a single reduced result

02:27.400 --> 02:27.800
Now

02:27.800 --> 02:31.500
it turns out that we can make some changes to splitting

02:31.500 --> 02:34.200
we can make some changes to combining

02:34.200 --> 02:43.600
but we're pretty much stuck with the way the apply phase works because there aren't many knobs for controlling The coming-forth Joint

02:43.600 --> 02:44.100
Well

02:44.100 --> 02:44.400
we'll see that

02:44.400 --> 02:50.000
There's a few little simple knobs like influencing the number of threads or the 4th July pool

02:50.000 --> 02:51.700
but you really can't control

02:51.700 --> 02:52.800
for example

02:52.800 --> 02:55.000
the order in which the processing takes place in parallel

02:55.000 --> 02:56.800
that that's not something you really can control

02:56.800 --> 03:01.700
So you got to come to grips with what you can control and then learn how to use those control

03:01.700 --> 03:02.700
knobs effectively

03:02.700 --> 03:05.200
to optimizing Junior code