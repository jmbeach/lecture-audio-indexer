We're going to do now. We're going to talk about the order of results for operations.
 So, before we talked about the order results for collections, now, we're going to talk about the order of results that are affected by the operations that you may happen to choose.
 And again, we're going to look it up a bunch of examples. This is actually kind of fun is lots of interesting things here.
 As was the case earlier, if you take a look at the ex21 folder in my GitHub repository, you'll find all the examples there.
 So, certain intermediate operations, affect ordering behavior and we'll take a look and see what they are. We'll start by looking at sorehead, unordered, Skip and limit and I'll demonstrate some of these things in the context of several examples that kind of difference of each other.
 So once again, we'll start by looking at some input. In this case. We're going to have
 A list created that has the values. 23142 in that order.
 And that will be the encounter order and that's because a list is both ordered and non-unique. So we have to worry about having duplicates.
 The next thing we do is we call distinct. So we create a parallel stream from that original list and then we called distinct and distinct is a stateful, intermediate operation, and that will, of course, go ahead and remove duplicate elements. So now will end up with the stream that will be busy p2314.
 And then we're also going to go ahead and limit the amount of processing. It takes place here to some parameter passed into the limit intermediate operation. So let's assume s output limit had the value of two or something like that. That would then also be a stateful, intermediate operation. And that means we're only going to process that many elements in the Stream. So it's what color short-circuiting stateful, intermediate operation.
 Now, after all of this stuff will end up with a result that will be eight followed by 4, and that's because we're going to end up with with the duplicates are removed. And
 This will be the encounter order because everything we saw along the way preserved, the ordering property. However, the performance of this code will be rather slow because limit and distinct have so-called stateful semantics which require additional processing in parallel streams. So be aware that the choice of the interview. Operation can affect the behavior as well as also affect the performance as well.
 Now, if we go ahead and insert the unordered call after we make a parallel stream, this will end up allowing the code to run more efficiently because there's no need to preserve the encounter order. So, therefore, these animated operations like limit and distinct can incur less overhead. And that's not a good thing at the wind because we made things faster by not caring about the order in which things occur.
 Since the encounter order doesn't have to be maintained, the result could be eight followed by 4 or 4 elevate. It doesn't really matter.
 Certain terminal operations, also, affect ordering Behavior. So we already saw how intermediate, operations, affected the Behavior. Now, we're going to take a look and see how criminal operations affect the ordering Behavior.
 The most obvious Journal operation, that will affect ordering behavior is the for each ordered method. And the whole purpose of, for each ordered is to ensure that we end up with ordering preserve. We want to preserve the encounter order.
 So you can take a look here and see that if we, if we write this code and we use the arraylist to be 2314 to run this thing and parallel. We use for each ordered then we'll be able to have the results. The order. However, we have to be very careful here because this list is only going to support unsynchronized insertion and removal of elements because it's just a plain old Ray list.
 Now, the thing is so wacky here. Is that even though we're using a parallel stream here. We will still end up getting results that don't have race conditions, and that's because the results must appear in encounter order.
 Now this is really strange. This will work properly using for each ordered, but it will be slow, and that's because there's implicit synchronization. It's performed in the for each ordered method. Were you to use the for each method here, then chaos and Insanity with him soon because we would be simultaneously accessing and unsynchronized, arraylist.
 Let's go take a look at how you could use for each properly that member for each does not attempt to preserve encounter order.
 And instead what we do here as we create the results variable to be a concurrent linked to rather than an arraylist. If you showed here and this code will work properly because results will be properly synchronized but the order doesn't have to be preserved. So it might be faster than for each ordered. It might be about the same because we're still using synchronized data structure. Is it just kind of depends on whether concurrently accuse synchronizers any faster than for each ordered linked for each ordered synchronizer. So you can have to pick your poison there. I would probably not recommend writing any of this code with a for each Loop and a results.
 Do our results list. It's just there better ways to do it using collect. So I'm just kind of showing you that the ordering of for each. And for each all difference.
 Okay.
 So that basically wraps up our discussion about ordering results for operations, which is one of the things that you can, in fact, control in Java Carol Streams, even though ordering a processing is not really something that you can control.