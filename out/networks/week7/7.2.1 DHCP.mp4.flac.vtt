00:00.000 --> 00:04.400
The next topic World discuss is how we assign IP addresses

00:04.400 --> 00:09.600
So how do we first come up with an IP address for a particular interface

00:09.600 --> 00:10.300
So

00:10.300 --> 00:11.400
for particular computer

00:11.400 --> 00:14.300
so there are a few mechanisms for this

00:14.300 --> 00:15.600
Typically

00:15.600 --> 00:17.900
it's done through a bootstrap anger startup process

00:17.900 --> 00:22.500
There are two mechanisms will discuss that accomplish

00:22.500 --> 00:24.300
This one is called DHCP

00:24.300 --> 00:29.300
which anode wood used to learn a ton configuration parameters

00:29.300 --> 00:35.500
There is another process to learn the link layer

00:35.500 --> 00:37.300
address to serve other nodes

00:37.300 --> 00:38.600
which is done with ARP

00:38.600 --> 00:39.200
So

00:39.200 --> 00:42.700
first talk primarily about DHCP

00:43.700 --> 00:44.500
So for example

00:44.500 --> 00:45.700
what IP address

00:45.700 --> 00:48.200
if we've added a new host to a network

00:48.200 --> 00:52.500
what IP address should that hose to use what DNS server should it use

00:52.500 --> 00:54.900
how can it disambiguation

00:54.900 --> 00:58.700
which destinations are local versus on some external network

00:58.700 --> 01:03.900
How could we address to those destinations if they are local

01:03.900 --> 01:07.500
And then how do we send packets out to remote destination

01:07.500 --> 01:09.200
Typically through some Gateway router

01:09.200 --> 01:12.300
So those are the problems were going to try to address

01:12.300 --> 01:17.300
So we'd prefer not to just in code all of this information manually

01:17.300 --> 01:18.300
that would be one solution

01:18.300 --> 01:21.600
but it'll be pretty brittle and it wouldn't scale

01:21.600 --> 01:21.800
Well

01:21.800 --> 01:26.800
so DHCP stands for the dynamic host configuration protocol

01:26.800 --> 01:28.800
and with this each and host

01:28.800 --> 01:30.600
would learn how to send Pockets

01:30.600 --> 01:32.800
So basically it would learn IP addresses

01:32.800 --> 01:33.800
DNS servers

01:33.800 --> 01:36.000
Gateway node

01:36.000 --> 01:41.000
to send information out through two other networks and what it what the address is our local

01:41.600 --> 01:44.500
In the address resolution protocol ARP

01:44.500 --> 01:46.900
This is for a local destinations

01:46.900 --> 01:55.100
This would discover the mapping between IP addresses that are used at the network layer and Mac address for this

01:55.100 --> 01:56.600
which are used at the link layer

01:56.600 --> 02:01.100
So a lower-level addressing

02:02.500 --> 02:06.900
So for both Protocols are a few key ideas out of the first is broadcasting

02:06.900 --> 02:08.000
So if you don't know something

02:08.000 --> 02:09.400
shout to get the answer

02:09.400 --> 02:14.300
the broadcast query would be sent to All hosts in the local area networks

02:14.300 --> 02:18.200
and the land that you're connected to and this is what you do

02:18.200 --> 02:25.200
If you don't know how to identify the correct other hosts cashing will also be incorporated in these protocols

02:25.200 --> 02:38.300
to remember a past information for a while so store what you learn to reduce overhead and having to send too many requests for information and also to store your own address and other hosts addresses

02:39.200 --> 02:43.500
So this casting process is also a form of soft States

02:43.500 --> 02:43.900
We'd eventually

02:43.900 --> 02:45.100
forget the past

02:45.100 --> 02:49.400
So you'd associate sometime to live with that information

02:49.400 --> 02:55.500
And then either refresher discard information if it times out and this is important for robustness

02:55.500 --> 02:57.900
in case of unpredictable changes

02:59.700 --> 03:00.900
So

03:00.900 --> 03:02.800
what's the MAC address versus an IP address

03:02.800 --> 03:06.000
So the MAC address is something that's hard-coded

03:06.000 --> 03:11.000
Whereas the IP addresses is something that would be configured or learned dynamically

03:11.000 --> 03:11.400
So

03:11.400 --> 03:11.900
you can sort of

03:11.900 --> 03:15.800
think of a MAC address like a social security number and an IP address

03:15.800 --> 03:18.400
like a postal mailing address number

03:18.400 --> 03:19.000
So

03:19.000 --> 03:21.900
you can if you move probably you keep the same social security number

03:21.900 --> 03:29.000
but you might wind up with a new postal address Mac addresses or a flat namespace of 48 bits

03:29.000 --> 03:32.900
So that typically be written in Acts and looks something like this

03:34.000 --> 03:43.700
Are they be portable and they could stay the same as a host would move around and this is what to use that the link later to get packets between interfaces on the network

03:43.700 --> 03:45.300
And contrast

03:45.300 --> 03:47.100
as we've already seen IP addresses

03:47.100 --> 03:50.700
are hierarchical namespace using 32 bits

03:50.700 --> 03:53.300
So that dotted quad notation is

03:53.300 --> 03:54.800
wouldn't necessarily be portable

03:54.800 --> 03:57.200
It would depend on where the host is attached

03:57.200 --> 04:00.900
But this is what to use for doing the network layer

04:00.900 --> 04:05.300
the internet level routing to figure out destination

04:05.300 --> 04:07.100
IP subnet

04:09.400 --> 04:14.700
So the bootstrap problem is that when a host gets connected to a network or turns on

04:14.700 --> 04:16.300
it doesn't have an IP address yet

04:16.300 --> 04:22.800
So it doesn't know what source address to use to send information out using the IP protocol

04:24.200 --> 04:26.500
It also doesn't know who to ask for an IP address

04:26.500 --> 04:32.200
So what it'll do it first to be able to figure out what destination

04:32.200 --> 04:33.500
Addresses would make sense

04:33.500 --> 04:34.700
And what's worse address

04:34.700 --> 04:35.900
It's been a sign

04:35.900 --> 04:40.500
Is it would send out a broadcast to discover a server that can help

04:40.500 --> 04:45.500
So I broadcast out of server Discovery message to this special Mac address

04:45.500 --> 04:48.300
then the server or possibly servers running

04:48.300 --> 04:48.600
Say

04:48.600 --> 04:52.800
DHCP would respond back offering an address

04:53.900 --> 04:56.100
So the response from the DHCP server

04:56.100 --> 04:58.300
I would consist of an offer this

04:58.300 --> 05:03.500
it have configuration parameters like the proposed IP address mask information

05:03.500 --> 05:07.000
a Gateway router IP address DNS server IPs at cetera

05:07.000 --> 05:09.100
It also include a lease time

05:09.100 --> 05:12.800
which should be the duration for which that IP address would remain valid

05:12.800 --> 05:15.300
Several servers could respond

05:15.300 --> 05:19.200
There might be multiple DHCP server is on the same broadcast network

05:19.200 --> 05:21.300
They could each respond

05:21.300 --> 05:23.500
but you should probably just pick one of them

05:23.500 --> 05:24.000
Otherwise

05:24.000 --> 05:25.900
your IP address wouldn't be unique

05:25.900 --> 05:39.100
The client would send the request act when the parameters back to accept an offer and the DHCP server would respond with an acknowledgement and the other DHCP server

05:39.100 --> 05:40.400
So if there are multiple offers

05:40.400 --> 05:42.600
they would see that they weren't chosen

05:43.500 --> 05:44.300
The roughly

05:44.300 --> 05:48.000
This is what I run of the protocol would look like a DHCP

05:48.000 --> 05:52.200
Discover get sent to sent out through the broadcast mechanism

05:52.200 --> 05:55.600
So that all computers are all things attached to the network

05:55.600 --> 06:00.300
It would offer an IP address Gateway information at cetera to the client

06:00.300 --> 06:05.700
If the client could broadcast back sending a request that

06:05.700 --> 06:05.900
okay

06:05.900 --> 06:09.400
I'll take that and then the DHCP server would acknowledge back

06:09.400 --> 06:14.800
So why do we incorporate a least

06:14.800 --> 06:16.000
I'm so

06:16.000 --> 06:18.900
so that information can be forgotten

06:18.900 --> 06:27.000
So the client could request release of the IP address to get a new IP address where this could occur if the client shuts down

06:27.000 --> 06:28.400
However

06:28.400 --> 06:30.500
the client might not release the address

06:30.500 --> 06:32.500
So I suppose the computer crashes

06:32.500 --> 06:40.900
If you don't release the address and have a timeout then that address would have been allocated forever and we want to avoid that scenario

06:40.900 --> 06:43.500
So there can be some performance trade-off

06:43.500 --> 06:45.100
With these least

06:45.100 --> 06:45.400
I'm

06:45.400 --> 06:47.100
so if it's a short leash time

06:47.100 --> 06:51.600
the address that's been allocated what time out quickly

06:51.600 --> 06:52.500
But if it's long

06:52.500 --> 06:55.300
you would avoid the silver had a frequent renewal

06:55.300 --> 07:13.600
but it would increase potentially the chance of running out of IP addresses to another host has information like what the IP addresses that it's been assigned with the network mask is or what the subnet information is

07:13.600 --> 07:16.100
What a Gateway is and what DNS servers are

07:16.100 --> 07:19.500
So now it could send out packets to other IP address

07:19.500 --> 07:24.000
but how come the local or can we use the local network to accomplish this

07:25.300 --> 07:30.300
So how would I know to figure out if it's sending something locally versus remotely

07:30.300 --> 07:31.900
So there's two cases for this

07:31.900 --> 07:32.300
right

07:32.300 --> 07:34.700
If the destinations on the local network

07:34.700 --> 07:36.100
you can go ahead and address it directly

07:36.100 --> 07:37.800
If it's not

07:37.800 --> 07:39.900
then you need to figure out where to send it through

07:39.900 --> 07:41.800
which typically would be the Gateway router

07:43.000 --> 07:45.900
So if it's on the local network

07:45.900 --> 07:49.200
you can determine that by comparing the mask

07:50.100 --> 07:51.300
That's been assigned

07:51.300 --> 08:03.400
So if you take the destination address and can jump it with the mask and then if you get back the same value as when the host's own addresses mask

08:03.400 --> 08:03.800
then you know

08:03.800 --> 08:04.500
it's local

08:04.500 --> 08:05.300
So for example

08:05.300 --> 08:16.000
if this host wanted to send something to this host and it took the mask of this and make it back something like 1.2.3, and it would know that

08:16.000 --> 08:16.400
Okay

08:16.400 --> 08:17.200
the

08:17.200 --> 08:18.100
7 is awesome

08:18.100 --> 08:19.300
The same local network

08:21.800 --> 08:22.800
So if it's a remote

08:22.800 --> 08:23.100
though

08:23.100 --> 08:26.500
we need to look up the first stop on the local routing table

08:26.500 --> 08:29.300
So that would be whatever

08:29.300 --> 08:30.300
Gateway had been assigned

08:30.300 --> 08:41.700
So then we would do the same thing for the local case for this Gateway rather than the ultimate ultimate to add destination IP address for the local case

08:41.700 --> 08:44.200
We need to figure out the destinations Mac address

08:44.200 --> 08:49.600
And the reason that we would need to do that is because sending packets over a link

08:49.600 --> 08:52.600
the network interface cards on the understand Mac addresses

08:52.600 --> 08:57.200
So that destination IP address needs to get translated into a MAC address

08:57.200 --> 09:04.600
And what would occur is the IP packet would get encapsulated inside of a link level frame

09:04.600 --> 09:05.200
right

09:05.200 --> 09:05.500
So basically

09:05.500 --> 09:12.800
we would prefix in front of it the link level information as we've seen some other earlier examples of